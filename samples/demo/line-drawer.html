<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>画线</title>
    <script src="../node_modules/rxjs/bundles/rxjs.umd.min.js"></script>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
      }
      #path {
        width: 100vw;
        height: 100vh;
        display: block;
        padding: 0;
        margin: 0;
      }
      #distance-container {
        position: fixed;
        top: 8px;
        right: 8px;
      }
    </style>
  </head>
  <body>
    <canvas id="path"></canvas>
    <div id="distance-container">Distance: <br/><span id="distance">0</span></div>
    <script>
      // 当前点和上一个点之间的直线距离之和
      // 并画出路径
      {
        const dpi = window.devicePixelRatio
        const { fromEvent, of } = rxjs
        const { mergeScan, distinct } = rxjs.operators

        function distanceOf([x1, y1], [x2, y2]) {
          return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2))
        }

        class Drawer {
          constructor() {
            const canvas = document.getElementById("path")
            // fix canvas
            const style = getComputedStyle(canvas)
            const dimen = name => +style.getPropertyValue(name).slice(0, -2)
            canvas.setAttribute("width", dimen("width") * dpi)
            canvas.setAttribute("height", dimen("height") * dpi)

            const ctx = canvas.getContext("2d")
            ctx.scale(dpi, dpi)

            this.canvas = canvas
            this.ctx = ctx
          }

          clear() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)
          }

          drawPoint(point, color) {
            if (color) {
              const oldStyle = this.ctx.fillStyle
              this.ctx.fillStyle = color
              this.ctx.fillRect(point[0] - 2, point[1] - 2, 4, 4)
              this.ctx.fillStyle = oldStyle
            } else {
              this.ctx.fillRect(point[0] - 2, point[1] - 2, 4, 4)
            }
          }

          drawPath(path) {
            if (path.length <= 0) {
              return
            }
            this.clear()
            this.drawPoint(path[0], "violet")

            const ctx = this.ctx
            ctx.beginPath()
            ctx.moveTo(path[0][0], path[0][1])
            for (let i = 1; i < path.length; i++) {
              const point = path[i]
              this.drawPoint(point)
              ctx.lineTo(point[0], point[1])
            }
            ctx.stroke()
          }

          drawDistance(distance) {
            document.getElementById('distance').innerText = distance;
          }

          draw(info) {
            this.drawPath(info.path)
            this.drawDistance(info.distance)
          }
        }

        const drawer = new Drawer()

        function createState() {
          return { distance: 0, path: [] }
        }

        function scanState({ path, distance }, { clientX: x, clientY: y }) {
          if (path.length === 0) {
            return of({ distance: 0, path: [[x, y]] })
          }
          const move = distanceOf([x, y], path[path.length - 1])
          return of(
            move >= 4
              ? {
                  distance: distance + move,
                  path: [...path, [x, y]]
                }
              : { distance, path }
          )
        }

        fromEvent(document, "click")
          .pipe(
            mergeScan(scanState, createState()),
            distinct(state => state.distance)
          )
          .subscribe(info => {
            console.log(info)
            drawer.draw(info)
          })
      }
    </script>
  </body>
</html>
